% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/geom-arrowsegment.R
\name{geom_arrowsegment}
\alias{geom_arrowsegment}
\title{Line segments with flexible arrows}
\usage{
geom_arrowsegment(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  arrows = list(arrow()),
  arrow_fills = NULL,
  arrow_positions = 1,
  lineend = "butt",
  linejoin = "round",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
}
\arguments{
\item{mapping}{Set of aesthetic mappings created by \code{\link[ggplot2:aes]{aes()}} or
\code{\link[ggplot2:aes_]{aes_()}}. If specified and \code{inherit.aes = TRUE} (the
default), it is combined with the default mapping at the top level of the
plot. You must supply \code{mapping} if there is no plot mapping.}

\item{data}{The data to be displayed in this layer. There are three
options:

If \code{NULL}, the default, the data is inherited from the plot
data as specified in the call to \code{\link[ggplot2:ggplot]{ggplot()}}.

A \code{data.frame}, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
\code{\link[ggplot2:fortify]{fortify()}} for which variables will be created.

A \code{function} will be called with a single argument,
the plot data. The return value must be a \code{data.frame}, and
will be used as the layer data. A \code{function} can be created
from a \code{formula} (e.g. \code{~ head(.x, 10)}).}

\item{stat}{The statistical transformation to use on the data for this
layer, as a string.}

\item{position}{Position adjustment, either as a string, or the result of
a call to a position adjustment function.}

\item{...}{Other arguments passed on to \code{\link[ggplot2:layer]{layer()}}. These are
often aesthetics, used to set an aesthetic to a fixed value, like
\code{colour = "red"} or \code{size = 3}. They may also be parameters
to the paired geom/stat.}

\item{arrows}{A list of arrows, each generated by [grid::arrow()], defining the arrow
on the segment ended by the respective entry of `arrow_positions`. If this has length 1
then all arrows will have the same characteristics. The default is [grid::arrow()]
with default parameters.}

\item{arrow_fills}{A vector of fill colours for the arrowheads, behaves as
the `arrow_fill` option in [`geom_segment`].}

\item{arrow_positions}{A vector of distinct points on the unit interval. 0 is not
permitted but arbitrarily small values are; 1 is permitted. The default behaviour is that
arrowheads will be placed proportionally along the line connecting (`x`,`y`)
to (`xend`,`yend`) at these points.
In more detail: The first arrow segment begins at (`x`,`y`) and ends a proportional
distance along the straight line joining (`x`,`y`) and(`xend`,`yend`) equal to the first
entry of this vector. The second bridges the first two entries, and so on. If the final
entry is 1 then the last segment is an arrow (and hence usually an arrowhead will be
placed at the end of the line). If it is not, then  the last segment is simply a line.
These will be sorted into order from 0 to 1 if they are not already.}

\item{lineend}{Line end style (round, butt, square).}

\item{linejoin}{Line join style (round, mitre, bevel).}

\item{na.rm}{If \code{FALSE}, the default, missing values are removed with
a warning. If \code{TRUE}, missing values are silently removed.}

\item{show.legend}{logical. Should this layer be included in the legends?
\code{NA}, the default, includes if any aesthetics are mapped.
\code{FALSE} never includes, and \code{TRUE} always includes.
It can also be a named logical vector to finely select the aesthetics to
display.}

\item{inherit.aes}{If \code{FALSE}, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. \code{\link[ggplot2:borders]{borders()}}.}
}
\value{
A ggproto object
}
\description{
`geom_arrowsegment()` is parameterised much as [geom_segment()], and the default
`geom_arrowsegment()` is equivalent to `geom_segment(arrow = arrow())`. (It is
assumed that the user wants some kind of arrow.) The extended functionality is to
allow free placement of the arrowhead anywhere along the segment, and also multiple
arrowheads.
}
\details{
The function works by dividing the line up into 1 or more segment grobs, each of
which is generated by [grid::arrow()] except potentially the last (the closest
to the point (`xend`, `yend'`). The vector `arrow_positions`, whose entries must
lie between 0 and 1, defines where each arrow segment ends, as a proportional
position along the line. If the last entry of `arrow_positions` 1, then the last
grob has an arrow; otherwise it does not.

The function is designed with the expectation that arrows point from (`x`,`y`) to
(`xend`,`yend`) but the `arrows` argument will happily accept `arrow(ends = "first")`
or `arrow(ends = "both")` if you prefer. Just remember that the final segment is
only an arrow at all if the last entry of `arrow_positions` is 1.
}
\examples{

 library(tidyverse)
 # Generate some dummy data

 ten.points <- data.frame(line.no = rep(1:5, each = 2), x = runif(10), y = runif(10),
                          position = rep(c("start", "end"), 5))
 five.segments <- ten.points \%>\% pivot_wider(names_from = position, values_from = c(x,y))

 # Default behaviour

 ggplot(five.segments) +
    geom_point(data = ten.points, aes(x = x, y = y)) +
    geom_arrowsegment(aes(x = x_start, xend = x_end, y = y_start, yend = y_end))

 # Midpoint arrowheads

 ggplot(five.segments) +
    geom_point(data = ten.points, aes(x = x, y = y)) +
    geom_arrowsegment(aes(x = x_start, xend = x_end, y = y_start, yend = y_end),
                      arrow_positions = 0.5)

 # Double arrows

 ggplot(five.segments) +
    geom_point(data = ten.points, aes(x = x, y = y)) +
    geom_arrowsegment(aes(x = x_start, xend = x_end, y = y_start, yend = y_end),
                      arrow_positions = c(0.25, 0.75))

 # Double arrows, last arrowhead at the end point

 ggplot(five.segments) +
    geom_point(data = ten.points, aes(x = x, y = y)) +
    geom_arrowsegment(aes(x = x_start, xend = x_end, y = y_start, yend = y_end),
                      arrow_positions = c(0.25, 1))

 # Double arrowheads of varying appearance and position

 ggplot(five.segments) +
     geom_point(data = ten.points, aes(x = x, y = y)) +
     geom_arrowsegment(aes(x = x_start, xend = x_end, y = y_start, yend = y_end),
                       arrow_positions = c(0.25, 0.75),
                       arrows = list(arrow(angle = 45, type = "closed"),
                                     arrow(angle = 25, ends = "both")),
                       arrow_fills = "indianred")
}
